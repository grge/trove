# Trove v3 — Overall Architecture & Delivery Plan

Audience: dev team + docs.
Goal: ship a lean, well-typed Python SDK for Trove v3 and a separate MCP server that exposes the SDK over the Model Context Protocol. Keep the core small, ergonomic, and research-friendly.

---

## High-level Architecture

* **Two packages, one monorepo**

  * `packages/trove-sdk/` — Python library (sync+async, caching, rate limiting, citations, minimal ergonomic search).
  * `packages/trove-mcp/` — MCP server adapter that wraps `trove-sdk` services as MCP tools.
* **Layering inside `trove-sdk`**

  * **Transport** (httpx Client/AsyncClient, rate limit, cache hook).
  * **Raw resources**: 1:1 with v3 endpoints (`/result`, `/work/{id}`, `/newspaper/{id}`, `/people/{id}`, `/list/{id}`, titles as needed). Full param coverage, including all `l-*` limits, `facet`, `reclevel`, `encoding`, `bulkHarvest`, and cursor `s`.
  * **Iterators**: cursor pagination helpers; stable harvest mode (`bulkHarvest=true`).
  * **Ergonomic search (v1 minimal)**: fluent, immutable builder with just `.text() .in_() .page_size() .sort() .with_reclevel() .with_facets() .where() .harvest() .first_page() .pages() .records()`.
  * **Citations**: extract canonical PIDs from records, resolve PID/URL → record, emit BibTeX & CSL-JSON.
  * **Config & errors**: single config object; structured exceptions (`TroveError`, `RateLimitError`).
  * **(Optional) Models**: light Pydantic types for common payloads; always expose raw dicts.

---

## Monorepo Structure

```
/                                 # repo root
  packages/
    trove-sdk/
      trove/
        __init__.py
        config.py
        transport.py
        rate_limit.py
        cache.py
        params.py
        iterators.py
        resources/
          search.py
          work.py
          newspaper.py
          people.py
          lists.py
          titles.py
        citations.py
        exceptions.py
        models/           # optional, selective
      tests/
      pyproject.toml
      README.md
      docs/               # mkdocs or sphinx
    trove-mcp/
      trove_mcp/
        __init__.py
        server.py
        tools/
          search_page.py
          get_record.py    # work/article/people/list/title
          resolve_pid.py
          citation.py
      tests/
      pyproject.toml
  .github/workflows/ci.yml
  CONTRIBUTING.md
  CHANGELOG.md
```

* **Versioning**: separate versions for each package; semver.
* **Shared tooling**: Ruff/Black, mypy (strict on library code), pytest, coverage.
* **Python targets**: 3.10+.

---

## Documentation Plan

**Tooling**: MkDocs (Material) or Sphinx in `packages/trove-sdk/docs/`, built in CI and published on release.
**Principle**: docs are *definition-of-done per stage*; Stage 6 polishes & consolidates.

* **Doc sources**

  * Narrative guides in `/docs/` (how-tos, concepts).
  * API reference from docstrings (autogenerated).
  * Executable examples (doctest or pytest-style) to prevent rot.
* **Pages**

  1. *Getting started*: install, auth (`X-API-KEY`), first request, JSON vs XML.
  2. *Searching Trove*: categories, `q`, `facet`, `l-*` limits, pagination (`s`/`nextStart`), bulk harvest, caching & throttling usage.
  3. *Resources*: work, newspaper/gazette, people, list, titles; `include`/`reclevel`.
  4. *Ergonomic search vs raw*: three runnable examples, multi-category pagination caveat.
  5. *Citations*: canonical PIDs, resolution, BibTeX/CSL export.
  6. *Performance & reliability*: cache policy, rate limit/backoff, retries, error handling.
  7. *Changelog & compatibility*.
* **Ownership**

  * Devs maintain docstrings + examples.
  * You (or docs lead) own narratives, style, and cross-stage consistency.

---

## MCP Architecture (separate package, designed in parallel)

**Why separate**: keep SDK lightweight and broadly usable; MCP adds server/runtime deps.

* **Design goals**

  * Stateless tools; client resubmits cursors.
  * 1:1 mapping to SDK **service** functions (not internals).
  * Shared cache & rate limiter from SDK to be polite.
* **Tool surface (initial)**

  * `trove.search_page`

    * **Input**: `categories[]`, `q`, `limits{}`, `facet[]`, `n`, `sortby`, `reclevel`, `bulkHarvest`, `cursor`.
    * **Output**: `page_json`, `cursor_out` (the `nextStart` for that category).
  * `trove.get_work|get_article|get_people|get_list|get_title`

    * **Input**: `{id, include[], reclevel}`; **Output**: record JSON.
  * `trove.resolve_pid`

    * **Input**: `{pid_or_url}`; **Output**: `{kind, id, endpoint, record?}`.
  * `trove.citation`

    * **Input**: `{kind|record|pid, format: "bibtex"|"csl-json"}`; **Output**: string or dict.
* **Stateless multi-category pagination**

  * First call may include multiple categories.
  * Subsequent calls are **one category at a time** using that category’s `cursor_out` as `cursor`.
* **Config & security**

  * API key from env/secret store only (never from inputs).
  * Structured errors pass through (`status`, `message`, `retry_after?`).
* **Testing**

  * Contract tests: schemas ↔ SDK services.
  * E2E: mock transport; rate-limit & cache behavior.

---

## Key Technical Policies

* **Auth**: `X-API-KEY` header only (never `key=` in query).
* **Encoding**: default to `encoding=json`; allow XML passthrough if requested.
* **Pagination**: use `s="*"` then advance via `category[i].records.nextStart`.

  * Provide single-category `pages()/records()` helpers.
  * Multi-category: expose `pages_by_category()`/document separate follow-ups.
* **Caching**

  * Pluggable `CacheBackend` (memory default; SQLite persistent).
  * Normalized key: method + path + sorted query + vary headers (`Accept`, `encoding`, `reclevel`, `include`), excluding creds.
  * TTL presets: objects 7d (shorter if “coming soon”), search pages 5–15m. Per-route override allowed.
  * Future: conditional GETs when server exposes validators.
* **Rate limiting & retries**

  * Token bucket (`rate`, `burst`, `max_concurrency`) at transport level.
  * Respect `Retry-After` (seconds or HTTP date). Exponential backoff with jitter, capped.
  * Retries for idempotent GETs only; 4xx (non-429) are not retried.
* **Out of scope (v1)**

  * Contributor/partner registries and other non-research admin endpoints.
  * Write/annotation features if any exist.
  * Fancy search DSL & facet term objects (can land in v1.x).
* **Compatibility posture**

  * Pass through unknown params; don’t block on SDK updates for new `l-*`.
  * Light models; always expose raw dicts for future-proofing.

---

## Proposed Staged Implementation

> Dev team will rewrite detailed stage plans; here’s the top-level scaffold and definition of done per stage.

### Stage 1 — Foundation (Transport, Config, Errors)

* httpx transport (sync/async), shared request builder, `X-API-KEY`.
* Rate limiter + backoff; cache interface + MemoryCache.
* Exceptions; logging (redacted headers).
* **Docs**: README quickstart; auth; first request.
* **DoD**: first `GET /v3/result` smoke test; CI, lint, type checks green.

### Stage 2 — Complete Search

* Raw `SearchResource.page(**params)` with **all** query params; `params.build_limits`.
* Cursor iterators (`iter_pages`, `iter_records`) for **single category**; document multi-category behavior.
* Persistent SqliteCache + route TTLs.
* **Docs**: Searching guide (categories, limits, cursor), caching, rate limiting.
* **DoD**: page & record iterators verified; cache & rate-limit tests; examples runnable in CI.

### Stage 3 — Core Resources

* `work/{id}`, `newspaper/{id}` (and gazette if applicable), `people/{id}`, `list/{id}`, titles endpoints.
* Support `include`, `reclevel`, `encoding` on object GETs.
* **Docs**: resource pages with examples.
* **DoD**: contract tests per endpoint; 404/429 handling; examples pass.

### Stage 4 — Ergonomic Search (v1 minimal)

* Immutable `Search` builder with methods listed above; compiles to raw params.
* `.first_page() .pages() .records()`; clear error if >1 category for `.pages()` (or implement per-category paging helper).
* **Docs**: ergonomic vs raw; 3 runnable examples.
* **DoD**: parity with raw for single-category flows; examples run in CI.

### Stage 5 — Citations

* `CitationRef` extractors for article/work/people/list/title.
* PID/URL resolver (regex map + search fallback).
* BibTeX & CSL-JSON emitters.
* **Docs**: citing Trove (canonical PIDs, examples).
* **DoD**: round-trip tests (record → PID → record), formatter snapshots.

### Stage 6 — Models & Polish

* Optional Pydantic models (selective), `.raw` always available.
* Perf & robustness pass; logging polish; API reference build.
* **Docs**: full site polish; troubleshooting; changelog v1.0.
* **DoD**: API reference generated; docs pass link & example tests.

### Stage 7 — MCP Server (separate package)

* Tools: `search_page`, `get_*`, `resolve_pid`, `citation`.
* Shared cache/rate limiter; stateless pagination contract.
* **Docs**: quickstart for MCP users; tool schemas.
* **DoD**: contract tests vs SDK; E2E mock transport; packaged & versioned.

---

## Risks & Mitigations

* **Spec drift / response shape assumptions** → keep raw dict access; minimal models; pass-through params.
* **Rate limits** → conservative defaults; respect `Retry-After`; per-job throttle.
* **Example rot** → execute all examples in CI.
* **Multi-category pagination confusion** → document clearly; provide `pages_by_category()` helper in a minor release.

---

## Acceptance Criteria for v1.0

* Covers `/result` and object lookups (work, newspaper/gazette, people, list, titles) with full param support.
* Minimal ergonomic search works for single-category flows.
* Caching (memory + SQLite) and rate limiting enabled by default with safe presets.
* Citations: PID extraction & resolution + BibTeX/CSL output.
* Docs site published with runnable examples; API reference generated.
* Test suite green; type-checked; semver-tagged release.

---

If you want, I can turn this into repo scaffolding (folders, mkdocs config, CI workflow, and empty stage checklists) so the team can start filling in code and detailed plans immediately.

